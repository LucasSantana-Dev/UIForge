import { createClient } from '@/lib/supabase/server';
import { createBranch, pushFiles, createPR } from './operations';
import type { PRResult } from './types';

interface GeneratePRParams {
  userId: string;
  projectId: string;
  componentName: string;
  files: Array<{ path: string; content: string }>;
  prompt: string;
  model: string;
}

function generateBranchName(componentName: string): string {
  const slug = componentName
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '');
  const shortId = Math.random().toString(36).substring(2, 8);
  return `siza/generate-${slug}-${shortId}`;
}

export async function generateAndCreatePR(params: GeneratePRParams): Promise<PRResult> {
  const supabase = await createClient();

  const { data: repo, error: repoError } = await supabase
    .from('github_repos')
    .select(
      `
      *,
      github_installations!inner(
        installation_id,
        user_id
      )
    `
    )
    .eq('project_id', params.projectId)
    .eq('github_installations.user_id', params.userId)
    .single();

  if (repoError || !repo) {
    throw new Error('No GitHub repo linked to this project');
  }

  const [owner, repoName] = repo.full_name.split('/');
  const installationId = (
    repo.github_installations as unknown as {
      installation_id: number;
    }
  ).installation_id;
  const branchName = generateBranchName(params.componentName);

  await createBranch(installationId, {
    owner,
    repo: repoName,
    branchName,
    baseBranch: repo.default_branch,
  });

  await pushFiles(installationId, {
    owner,
    repo: repoName,
    branch: branchName,
    files: params.files,
    message: `feat(siza): generate ${params.componentName}`,
  });

  const prBody = [
    `## Generated by Siza`,
    '',
    `**Component:** ${params.componentName}`,
    `**Model:** ${params.model}`,
    `**Prompt:** ${params.prompt}`,
    '',
    `---`,
    `*This PR was automatically created by [Siza](https://siza.dev)*`,
  ].join('\n');

  const pr = await createPR(installationId, {
    owner,
    repo: repoName,
    title: `feat(siza): add ${params.componentName}`,
    body: prBody,
    head: branchName,
    base: repo.default_branch,
  });

  return pr;
}

export async function getLinkedRepo(userId: string, projectId: string) {
  const supabase = await createClient();

  const { data } = await supabase
    .from('github_repos')
    .select(
      `
      *,
      github_installations!inner(
        installation_id,
        account_login,
        user_id
      )
    `
    )
    .eq('project_id', projectId)
    .eq('github_installations.user_id', userId)
    .single();

  return data;
}

export async function linkRepoToProject(repoId: string, projectId: string) {
  const supabase = await createClient();

  await supabase.from('github_repos').update({ project_id: null }).eq('project_id', projectId);

  const { error } = await supabase
    .from('github_repos')
    .update({ project_id: projectId })
    .eq('id', repoId);

  if (error) throw error;
}

export async function unlinkRepo(projectId: string) {
  const supabase = await createClient();

  const { error } = await supabase
    .from('github_repos')
    .update({ project_id: null })
    .eq('project_id', projectId);

  if (error) throw error;
}
